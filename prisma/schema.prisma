generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Profile {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     User[]

  @@map("profiles")
}

model User {
  id               String       @id @default(cuid())
  email            String       @unique
  name             String?
  emailVerified    DateTime?
  image            String?
  phone            String?
  country          String?
  timezone         String?
  password         String
  profileId        String
  profile          Profile      @relation(fields: [profileId], references: [id])
  resetToken       String?
  resetTokenExpiry DateTime?
  loginLogs        LoginLog[]
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  organization     Organization? @relation("OrgUsers", fields: [organizationId], references: [id])
  organizationId   String?      @map("organization_id")
  subscriptions    Subscription[]
  payments         Payment[]
  stripeCustomerId String?      @map("stripe_customer_id")
  status           String       @default("ACTIVE")

  departmentLinks  DepartmentResponsible[]
  checkoutSessions CheckoutSession[]
  passwordResetTokens PasswordResetToken[]
  checklistExecutions ChecklistExecution[]

  @@map("users")
}

model LoginLog {
  id        Int      @id @default(autoincrement())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  ip        String?
  userAgent String?
  createdAt DateTime @default(now())

  @@map("login_logs")
}

model Organization {
  id             String    @id @default(cuid())
  name           String
  employeesCount Int       @map("employees_count")
  country        String
  city           String
  nicheId        String    @map("niche_id")
  niche          Niche     @relation(fields: [nicheId], references: [id])
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt      @map("updated_at")

  users          User[]    @relation("OrgUsers")
  branches       Branch[]
  checkoutSessions CheckoutSession[]

  @@map("organizations")
}

model Niche {
  id            String         @id @default(cuid())
  name          String         @unique
  description   String?        @db.Text
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt      @map("updated_at")

  organizations Organization[]

  @@map("niches")
}

model Branch {
  id             String       @id @default(cuid())
  name           String
  organizationId String       @map("organization_id")
  organization   Organization @relation(fields: [organizationId], references: [id])
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @updatedAt      @map("updated_at")
  wizardCompleted Boolean     @default(false) @map("wizard_completed")

  departments    Department[]
  environments   Environment[]
  checklists     Checklist[]

  @@map("branches")
}

model Department {
  id        String                  @id @default(cuid())
  name      String
  branchId  String                  @map("branch_id")
  branch    Branch                  @relation(fields: [branchId], references: [id])
  createdAt DateTime                @default(now()) @map("created_at")
  updatedAt DateTime                @updatedAt      @map("updated_at")

  responsibles DepartmentResponsible[]
  checklistItems ChecklistItem[]

  @@map("departments")
}

model DepartmentResponsible {
  departmentId String     @map("department_id")
  department   Department @relation(fields: [departmentId], references: [id])
  userId       String     @map("user_id")
  user         User       @relation(fields: [userId], references: [id])
  assignedAt   DateTime   @default(now()) @map("assigned_at")

  @@id([departmentId, userId])
  @@map("department_responsibles")
}

model Environment {
  id        String   @id @default(cuid())
  name      String
  branchId  String   @map("branch_id")
  branch    Branch   @relation(fields: [branchId], references: [id])
  position  Int?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt      @map("updated_at")

  checklists Checklist[]

  @@map("environments")
}

model Plan {
  id               String         @id @default(cuid())
  name             String         @unique
  price            Decimal
  includedUnits    Int            @map("included_units")
  maxUsers         Int            @map("max_users")
  extraUserPrice   Decimal?       @map("extra_user_price")
  maxChecklists    Int?           @map("max_checklists")
  extraUnitPrice   Decimal?       @map("extra_unit_price")
  isCustom         Boolean        @default(false) @map("is_custom")
  createdAt        DateTime       @default(now()) @map("created_at")
  updatedAt        DateTime       @updatedAt      @map("updated_at")

  subscriptions    Subscription[]
  checkoutSessions CheckoutSession[]

  @@map("plans")
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
}

model Subscription {
  id            String             @id @default(cuid())
  userId        String             @map("user_id")
  user          User               @relation(fields: [userId], references: [id])
  planId        String             @map("plan_id")
  plan          Plan               @relation(fields: [planId], references: [id])
  startDate     DateTime           @default(now()) @map("start_date")
  endDate       DateTime?          @map("end_date")
  status        SubscriptionStatus @default(ACTIVE)
  createdAt     DateTime           @default(now()) @map("created_at")
  updatedAt     DateTime           @updatedAt      @map("updated_at")

  invoices      Invoice[]
  payments      Payment[]

  @@map("subscriptions")
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
}

model Invoice {
  id              String        @id @default(cuid())
  subscriptionId  String        @map("subscription_id")
  subscription    Subscription  @relation(fields: [subscriptionId], references: [id])
  period          String        @map("period")
  amount          Decimal       @map("amount")
  issuedAt        DateTime      @default(now()) @map("issued_at")
  dueDate         DateTime      @map("due_date")
  paidAt          DateTime?     @map("paid_at")
  status          InvoiceStatus @default(PENDING)
  paymentId       String?       @map("payment_id") @unique
  payment         Payment?      @relation("InvoicePayment", fields: [paymentId], references: [id])
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt      @map("updated_at")

  @@unique([subscriptionId, period])
  @@map("invoices")
}

enum PaymentStatus {
  REQUIRES_PAYMENT_METHOD
  SUCCEEDED
  FAILED
}

model Payment {
  id                    String         @id @default(cuid())
  userId                String         @map("user_id")
  user                  User           @relation(fields: [userId], references: [id])
  subscriptionId        String?        @map("subscription_id")
  subscription          Subscription?  @relation(fields: [subscriptionId], references: [id])
  stripePaymentIntentId String         @map("stripe_payment_intent_id")
  amount                Decimal        @map("amount")
  currency              String         @default("BRL")
  status                PaymentStatus  @default(REQUIRES_PAYMENT_METHOD)
  error                 String?        @map("error")
  paidAt                DateTime?      @map("paid_at")
  createdAt             DateTime       @default(now()) @map("created_at")
  updatedAt             DateTime       @updatedAt      @map("updated_at")
  invoice               Invoice?       @relation("InvoicePayment")

  @@map("payments")
}

model CheckoutSession {
  id             String   @id @default(cuid())
  status         String   // pending, completed, failed
  amount         Float
  currency       String
  customerId     String
  organizationId String
  planId         String
  paymentMethod  String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  customer     User         @relation(fields: [customerId], references: [id])
  organization Organization @relation(fields: [organizationId], references: [id])
  plan         Plan         @relation(fields: [planId], references: [id])

  @@index([customerId])
  @@index([organizationId])
  @@index([planId])
}

model WebhookEvent {
  id          String   @id @default(uuid())
  type        String   // Tipo do evento (ex: checkout.session.completed)
  stripeId    String   @unique // ID do evento no Stripe
  data        Json     // Dados completos do evento
  processed   Boolean  @default(false) // Se o evento foi processado com sucesso
  error       String?  // Mensagem de erro, se houver
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([type])
  @@index([processed])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("password_reset_tokens")
}

model Checklist {
  id          String            @id @default(cuid())
  name        String
  description String?
  
  branchId    String            @map("branch_id")
  branch      Branch            @relation(fields: [branchId], references: [id])

  environmentId String          @map("environment_id")
  environment   Environment     @relation(fields: [environmentId], references: [id])

  actived     Boolean           @default(true)

  sections    ChecklistSection[]
  executions  ChecklistExecution[]

  createdAt   DateTime          @default(now()) @map("created_at")
  updatedAt   DateTime          @updatedAt      @map("updated_at")

  @@map("checklists")
}

model ChecklistSection {
  id           String           @id @default(cuid())
  name         String
  checklistId  String           @map("checklist_id")
  checklist    Checklist        @relation(fields: [checklistId], references: [id])

  items        ChecklistItem[]

  position     Int?

  createdAt    DateTime         @default(now()) @map("created_at")
  updatedAt    DateTime         @updatedAt      @map("updated_at")

  @@map("checklist_sections")
}

model ChecklistItem {
  id                     String                  @id @default(cuid())
  name                   String
  description            String?
  checklistSectionId     String                  @map("checklist_section_id")
  checklistSection       ChecklistSection        @relation(fields: [checklistSectionId], references: [id])

  position               Int?
  departmentId           String?                 @map("department_id")
  department             Department?             @relation(fields: [departmentId], references: [id])

  checklistResponseTypeId String                 @map("checklist_response_type_id")
  checklistResponseType   ChecklistResponseType  @relation(fields: [checklistResponseTypeId], references: [id])

  allowNotApplicable     Boolean                 @default(true)

  executionItems         ChecklistExecutionItem[]

  createdAt              DateTime                @default(now()) @map("created_at")
  updatedAt              DateTime                @updatedAt      @map("updated_at")

  @@map("checklist_items")
}

model ChecklistResponseType {
  id             String          @id @default(cuid())
  name           String          // Ex.: "Sim/Não", "Conforme/Não conforme"
  positiveLabel  String          // Label da resposta positiva (ex.: "Sim")
  negativeLabel  String          // Label da resposta negativa (ex.: "Não")
  description    String?

  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt      @map("updated_at")

  checklistItems ChecklistItem[]

  @@map("checklist_response_types")
}

enum ExecutionStatus {
  IN_PROGRESS
  COMPLETED
  CANCELED
}

model ChecklistExecution {
  id               String             @id @default(cuid())
  checklistId      String             @map("checklist_id")
  checklist        Checklist          @relation(fields: [checklistId], references: [id])

  performedById    String             @map("performed_by_id")
  performedBy      User               @relation(fields: [performedById], references: [id])

  status           ExecutionStatus    @default(IN_PROGRESS)

  items            ChecklistExecutionItem[]

  startedAt        DateTime           @default(now()) @map("started_at")
  completedAt      DateTime?          @map("completed_at")
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @updatedAt      @map("updated_at")

  @@map("checklist_executions")
}

model ChecklistExecutionItem {
  id                     String                @id @default(cuid())
  checklistExecutionId    String                @map("checklist_execution_id")
  checklistExecution      ChecklistExecution   @relation(fields: [checklistExecutionId], references: [id])

  checklistItemId         String               @map("checklist_item_id")
  checklistItem           ChecklistItem        @relation(fields: [checklistItemId], references: [id])

  isPositive              Boolean              // true = resposta positiva, false = negativa

  note                    String?              @db.Text
  photoUrl                String?              @map("photo_url")

  createdAt               DateTime             @default(now()) @map("created_at")
  updatedAt               DateTime             @updatedAt      @map("updated_at")

  @@map("checklist_execution_items")
}